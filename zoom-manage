#!/usr/bin/osascript

(*
 Copyright (c) 2023 Kayvan A. Sylvan

 Permission is hereby granted, free of charge, to any person obtaining a copy of
 this software and associated documentation files (the "Software"), to deal in
 the Software without restriction, including without limitation the rights to
 use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 the Software, and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *)

-- Global properties
property scriptName : "Zoom Manage"
property topLevelDirectory : missing value

-- Zoom Related properties
property appName : "zoom.us"
property appVersion : missing value
property topZoomWindow : "Zoom"
property meetingWindow : "Zoom Meeting"
property sharingWindow : "zoom share statusbar window"
property participantWindow : missing value

-- These three files are created in the logs/ subdirectory.
-- The pattern of filenames: logs/20231014-log.txt
-- This makes it easy to store and index the logs at a later time.
-- roster.txt is the running log file capturing the roster information.
-- log.txt is the overall log file.
-- filtered.txt is the filtered log file (capturing "Hands Raised", etc.)
property logFile : "log.txt"
property meetingRoster : "roster.txt"
property handsRoster : "filtered.txt"

-- The FastAPI server should be running at this URL
property trackerURL : "http://localhost:5000"
property batchCount : 50 -- can be set via ZOOM_MANAGE_BATCH_SIZE environment variable

-- Top level commands the script understands
property knownCommands : {Â
	"help", "reset", "roster", "hands", "camera_off", "admit", "server", "dashboard", Â
	"breakout", "camera_off", "camera_on", "phone", "no_audio", "muted", "unmuted"}

-- zoomRosterDebug uses the ZOOM_DEBUG environment variable.
-- If it is set to true, filtered rosters (like "hands") will be
-- output to the console (stderr) in addition to going in the log.
property zoomRosterDebug : missing value

on usageMessage(section)
	set tid to AppleScript's text item delimiters
	set AppleScript's text item delimiters to ":"
	set path_parts to every text item of ((path to me) as string)
	set AppleScript's text item delimiters to tid
	if section is "top" then
		return linefeed & "Usage: " & (item -1 of path_parts) & " [command]" & linefeed Â
			& "    help - show usage message." & linefeed & linefeed Â
			& "    server - run the backend server. Starts the server in its own terminal." & linefeed Â
			& "    dashboard - open the Zoom Meeting Tracker dashboard." & linefeed Â
			& "    reset - reset the tracking database." & linefeed & linefeed Â
			& "    roster (default action) - get current roster." & linefeed Â
			& linefeed Â
			& "    hands - get the current hands raised." & linefeed Â
			& "    camera_off - get the list of camera off participants." & linefeed Â
			& "    camera_on - get the list of participants who are on video." & linefeed Â
			& "    no_audio - get the list of participants not connected to audio." & linefeed Â
			& "    muted - get the list of participants who are muted." & linefeed Â
			& "    unmuted - get the list of participants who are unmuted." & linefeed Â
			& "    phone - get the list of participants dialing in by phone." & linefeed Â
			& linefeed Â
			& "    admit - admit everyone in the Waiting Room." & linefeed Â
			& "    breakout - create a set of named breakout rooms." & linefeed
	else
		return linefeed & "Usage: " & (item -1 of path_parts) & " breakout bor.txt" & linefeed Â
			& "Looks for " & topLevelDirectory & "breakout/bor.txt and creates the rooms named there." & linefeed Â
			& "Missing filename!" & linefeed
	end if
end usageMessage

on todayYMD()
	-- Return the current date in the format YYYYMMDD.
	set [_day, _month, _year] to [day, month, year] of (current date)
	set _month to _month * 1 --> 3
	set _month to text -1 thru -2 of ("0" & _month) --> "03"
	set _day to text -1 thru -2 of ("0" & _day)
	set result to _year & _month & _day
	return result
end todayYMD

on setUpLogFiles()
	-- setUpLogFiles handler:
	-- Creates a folder called "logs" in the same directory as the program if it does not already exist.
	-- It then creates two files, logFile and meetingRoster, in the logs folder, with a prefix of the current date.
	tell application "Finder"
		set _currentDirectory to container of (path to me)
		if not (exists folder "logs" of _currentDirectory) then
			make new folder at _currentDirectory with properties {name:"logs"}
		end if
	end tell
	set _currentDirectory to POSIX path of (_currentDirectory as text)
	set _prefix to my todayYMD()
	set topLevelDirectory to _currentDirectory
	set logFile to POSIX file (topLevelDirectory & "logs/" & _prefix & "-" & logFile)
	set meetingRoster to POSIX file (topLevelDirectory & "logs/" & _prefix & "-" & meetingRoster)
	set handsRoster to POSIX file (topLevelDirectory & "logs/" & _prefix & "-" & handsRoster)
	my setupEnvVariables()
end setUpLogFiles

on setupEnvVariables()
	-- zoomRosterDebug is false if ZOOM_DEBUG is not set
	set zoomRosterDebug to do shell script "echo ${ZOOM_DEBUG:-unset}"
	set zoomRosterDebug to (zoomRosterDebug is not "unset") -- set to false or true
	-- batchCount is set to value of ZOOM_MANAGER_BATCH_SIZE (50 if not set)
	set batchCount to do shell script "echo ${ZOOM_MANAGE_BATCH_SIZE:-" & batchCount & "}"
end setupEnvVariables

on formatDateTime(theDateTime)
	(*
	This code takes a date and time as input and formats it into a string in the form of MM/DD/YYYY HH:MM:SS.
	It does this by extracting the day, month, year, hours, minutes, and seconds from the input and
	adding a leading zero if necessary.
	*)
	set [_day, _month, _year, _hours, _minutes, _seconds] to [day, month, year, hours, minutes, seconds] of theDateTime
	set _month to _month * 1 --> 3
	set _month to text -1 thru -2 of ("0" & _month) --> "03"
	set _day to text -1 thru -2 of ("0" & _day)
	set _hours to text -1 thru -2 of ("0" & _hours) --> "05"
	set _minutes to text -1 thru -2 of ("0" & _minutes)
	set _seconds to text -1 thru -2 of ("0" & _seconds)
	set result to _month & "/" & _day & "/" & _year & " " & _hours & ":" & _minutes & ":" & _seconds
	return result
end formatDateTime

on logMessage(message, filePath)
	-- Usage:
	-- set logFilePath to (path to desktop as string) & "logfile.txt" -- Path to the log file
	-- my logMessage("This is a log message.", logFilePath)
	try
		-- Open the log file for writing, creating it if it doesn't exist
		set _log to open for access file filePath with write permission
		
		-- Construct the log entry
		set logEntry to (my formatDateTime(current date)) & " " & message & linefeed
		
		-- Write the log entry to the file
		write logEntry to _log starting at eof
		
		-- Close the log file
		close access _log
		
	on error errMsg number errNum
		-- If an error occurs, close the log file (if it's open)
		try
			close access _log
		end try
		-- Optionally, report the error in some way
		display dialog "Error: " & errMsg & " (" & errNum & ")"
	end try
end logMessage

on checkZoomRunning()
	-- This code checks if an application (appName) is running and if it is,
	-- it sets the variable appVersion to the version of the application.
	set _isRunning to false
	tell application "System Events"
		set _isRunning to (name of every process) contains appName
	end tell
	if not _isRunning then
		tell application appName to activate
	end if
	set appVersion to version of application appName
end checkZoomRunning

on findStatusMenu(nameSubstring)
	-- Find a status menu of Zoom that contains nameSubstring
	set _ret to missing value
	tell application "System Events" to tell process appName
		set menuItems to every menu item of menu 1 of menu bar 2
		repeat with m in menuItems
			if (exists name of m) and name of m contains nameSubstring then
				set _ret to m
				exit repeat
			end if
		end repeat
	end tell
	return _ret
end findStatusMenu

on clickStatusMenu(nameSubstring)
	-- Click a menu item in status menu
	tell application "System Events" to tell process appName
		set m to my findStatusMenu(nameSubstring)
		click m
		delay 1
	end tell
end clickStatusMenu

on enableParticipantsWindow()
	(*
	This code is used to click the "Manage Participants" menu item of the status menu bar.
	A delay of 1 second is added after the click.
	*)
	my clickStatusMenu("Participants")
	my logMessage("Participants panel started.", logFile)
end enableParticipantsWindow

on findSubWindow(nameOfApp, subWinName)
	-- Look for a sub-window of nameOfApp whose name contains subWinName
	tell application "System Events" to tell process nameOfApp
		set _wins to windows
		set _ret to missing value
		repeat with w in _wins
			if name of w starts with subWinName then
				set _ret to w
				exit repeat
			end if
		end repeat
	end tell
	return _ret
end findSubWindow

on findParticipantsWindow()
	tell application "System Events" to tell process appName
		if exists scroll area 1 of window meetingWindow then
			set participantWindow to window meetingWindow -- Participants panel.
		else
			set participantWindow to my findSubWindow(appName, "Participants")
		end if
	end tell
end findParticipantsWindow

on startParticipantWindow()
	tell application "System Events" to tell process appName
		my findParticipantsWindow()
		if participantWindow is missing value then
			my enableParticipantsWindow() -- participant window started
		end if
		my findParticipantsWindow()
	end tell
end startParticipantWindow

on checkZoomMeetingRunning()
	repeat
		-- Make sure we are in a Zoom meeting
		tell application "System Events" to tell process appName
			set _startMeetingMenu to my findStatusMenu("Join a Meeting")
			if _startMeetingMenu is not missing value then
				display dialog "The " & scriptName & " application needs a Zoom Meeting." & linefeed & "Please join the Zoom Meeting and press OK."
			else
				exit repeat
			end if
		end tell
	end repeat
end checkZoomMeetingRunning

on appLogMessage(message)
	my logMessage("=== " & scriptName & ": " & message, logFile)
end appLogMessage

on resetTrackigData()
	do shell script "curl -X POST " & trackerURL & "/reset"
end resetTrackigData

on replaceText(theText, searchStr, replacementStr)
	if theText does not contain searchStr then
		return theText -- return the original string if it doesn't contain the search string
	end if
	set oldDelims to AppleScript's text item delimiters -- save old delimiters
	set AppleScript's text item delimiters to the searchStr
	set theTextItems to every text item of theText
	set AppleScript's text item delimiters to the replacementStr
	set theText to theTextItems as string
	set AppleScript's text item delimiters to oldDelims -- restore old delimiters
	return theText
end replaceText

on trackList(_nameList, apiEndpoint)
	if (count _nameList) is 0 then
		return
	end if
	set cmd to "curl -X PUT -H 'Content-Type: application/json' -d ' ["
	set qList to {}
	repeat with n in _nameList
		set qList to qList & {"\"" & n & "\""}
	end repeat
	set _tid to AppleScript's text item delimiters
	set AppleScript's text item delimiters to ","
	set cmd to cmd & (qList as string) & "]' " & trackerURL & apiEndpoint
	set AppleScript's text item delimiters to _tid
	do shell script cmd
	-- log cmd
end trackJoined

on trackListBatched(_nameList, apiEndpoint)
	set _nameCount to count _nameList
	repeat with i from 1 to _nameCount by batchCount
		set endIndex to i + batchCount - 1
        if endIndex > _nameCount then set endIndex to _nameCount
		my trackList(items i thru endIndex of _nameList, apiEndpoint)
	end repeat
end trackListBatched

on trackJoined(_nameList)
	my trackListBatched(_nameList, "/joined_list")
end trackJoined

on trackWaiting(_nameList)
	my trackListBatched(_nameList, "/waiting_list")
end trackWaiting

on runBackendServer()
	-- check if the server is already running
	set serverRunning to false
	try
		set jsonOutput  to do shell script "curl -X GET " & trackerURL & "/health -H 'accept: application/json'"
		if jsonOutput starts with "{" then set serverRunning to true
	on error errMessage number errNUm
		error errMessage number errNum
	end try
	if serverRunning then
		error "Server is already running. " & jsonOutput number -1
	end if
	set titleString to "\\033]0;" & scriptName & " Backend Server\\007"
	set cmd to "echo -n -e \"" & titleString & "\";cd " & topLevelDirectory & "backend; ./server.py; exit"
	tell application "Terminal"
		activate
		if (count of windows) is 0 then
            do script cmd
        else
            do script cmd in window 1
        end if
	end tell
end runBackendServer

on openDashboard()
	do shell script "open " & topLevelDirectory & "frontend/index.html"
end openDashboard

on writeToRoster(message, filePath)
	-- Usage:
	-- set logFilePath to (path to desktop as string) & "roster.txt" -- Path to the roster file
	-- my writeTeRoster("John Smith", logFilePath)
	try
		-- Open the log file for writing, creating it if it doesn't exist
		set _log to open for access file filePath with write permission
		set _line to message & linefeed
		write _line to _log starting at eof
		-- Close the log file
		close access _log
		-- optionally log to stderr
		if zoomRosterDebug then
			log message
		end if
	on error errMsg number errNum
		-- If an error occurs, close the log file (if it's open)
		try
			close access _log
		end try
		-- Optionally, report the error in some way
		display dialog "Error: " & errMsg & " (" & errNum & ")"
	end try
end writeToRoster

on generateRoster()
	set _joinedList to {}
	set _waitingList to {}
	set _joinedPrefix to "Joined "
	set _waitingPrefix to "Waiting Room "
	tell application "System Events" to tell process appName
		tell outline 1 of scroll area 1 of participantWindow
			set allParticipantNames to get value of static text of UI element of rows
			set _intro to "=== " & (my formatDateTime(current date)) & " ==="
			my writeToRoster(_intro, meetingRoster)
			set [_waiting, _joined] to [0, 0] -- The number in Waiting Room and the numner Joined
			set _num to (count allParticipantNames)
			set _inWaitingList to false
			set _inJoinedList to false
			repeat with i from 1 to _num
				set _pName to item i of allParticipantNames as string
				set _pName to my replaceText(_pName, "'", "-") -- Hack for people with single-quotes in their name

				if _pName starts with _waitingPrefix then
					set _inWaitingList to true
				end if
				if _pName starts with _joinedPrefix then
					set _inWaitingList to false
					set _inJoinedList to true
				end if
				if (i is 1) and (not _inWaitingList) and (not _inJoinedList) then
					set _inJoinedList to true
					set _joined to 1
				end if
				set _numPrefix to ""
				if _inWaitingList and (_waiting > 0) then
					set _numPrefix to " " & (_waiting as string) & ". "
				end if
				if (not _inWaitingList) and (_joined > 0) then
					set _numPrefix to " " & (_joined as string) & ". "
				end if
				my writeToRoster(_numPrefix & _pName, meetingRoster)
				if _inWaitingList then
					if not (_pName starts with _waitingPrefix) then
						set _waiting to _waiting + 1
						set _waitingList to _waitingList & {_pName}
					end if
				else
					if not (_pName starts with _joinedPrefix) then
						set _joined to _joined + 1
						set _joinedList to _joinedList & {_pName}
					end if
				end if
			end repeat
			if _joined > 1 then
				set _joined to _joined - 1
			end if
			if _waiting > 1 then
				set _waiting to _waiting - 1
			end if
			
			set _sum to _joined + _waiting
			if _sum > 1 then
				set plural to "s"
			else
				set plural to ""
			end if
			set _summary to "=== " & (_sum as string) & " participant" & plural Â
				& " " & (my formatDateTime(current date)) & " ==="
			my writeToRoster(_summary, meetingRoster)
		end tell
	end tell
	my trackWaiting(_waitingList)
	my trackJoined(_joinedList)
end generateRoster

on joinStringList(_strings)
	set _tid to AppleScript's text item delimiters
	set AppleScript's text item delimiters to ":"
	set _ret to _strings as string
	set AppleScript's text item delimiters to _tid
	return _ret
end joinStringList

on generateFilteredRoster(filterString)
	-- Look for filter strings in the description strings in participants window
	set _intro to "=== " & filterString & " " & (my formatDateTime(current date)) & " ==="
	my writeToRoster(_intro, handsRoster)
	set _num to 0
	tell application "System Events" to tell process appName
		tell outline 1 of scroll area 1 of participantWindow
			set allParticipantNames to get value of static text of UI element of rows
			set numPart to (count allParticipantNames)
			set allRows to rows
			repeat with i from 1 to numPart
				set pName to item i of allParticipantNames as string
				set aRow to item i of allRows
				set allElem to UI elements of (item 1 of UI element of aRow)
				set allDescriptions to description of UI elements of (item 1 of UI element of aRow)
				set joinedDescription to my joinStringList(allDescriptions)
				if joinedDescription contains filterString then
					set _num to _num + 1
					set _msgToLog to (_num as string) & " " & pName
					my writeToRoster(_msgToLog, handsRoster)
				end if
			end repeat
		end tell
	end tell
	if _num > 1 then
		set plural to "s"
	else
		set plural to ""
	end if
	set _summary to "=== " & filterString & " " & (_num as string) & " participant" & plural & Â
		" " & (my formatDateTime(current date)) & " ==="
	my writeToRoster(_summary, handsRoster)
end generateFilteredRoster

on letPeopleIn()
	set checkForWaitingRoom to true
	repeat while checkForWaitingRoom
		tell application "System Events" to tell process appName
			tell outline 1 of scroll area 1 of participantWindow
				-- Fetch all the rows in the Participants list.
				set participantRows to every row
				-- Check to see if Waiting Room exists.
				set firstRowName to (get value of static text of UI element of row 1) as string
				if firstRowName does not start with "Waiting Room " then
					exit repeat
				end if
				set checkForWaitingRoom to false
				-- Loop through each participant row and click the "Admit" button.
				repeat with aRow in participantRows
					if checkForWaitingRoom then
						exit repeat
					end if
					set pName to (get value of static text of UI element of aRow) as string
					if pName starts with "Joined " then
						exit repeat
					end if
					set allElem to UI elements of (item 1 of UI element of aRow)
					repeat with anElem in allElem
						if description of anElem is "Admit" then
							click anElem
							delay 1
							set checkForWaitingRoom to true
							my logMessage("Waiting Room: Admitted " & pName, logFile)
							exit repeat
						end if
					end repeat
				end repeat
			end tell
		end tell
	end repeat
end letPeopleIn

on createBreakoutRooms(breakoutFilename)
	set borFilePath to topLevelDirectory & "breakout/" & breakoutFilename
	tell application "System Events"
		if (not (exists file borFilePath)) then
			error ("Missing breakout file: " & borFilePath) number -1
		end if
		set _size to size of (info for POSIX file borFilePath)
		if _size is 0 then
			error ("Empty breakout file: " & borFilePath) number -2
		end if
	end tell
	
	set bFile to POSIX file (borFilePath)
	set _file to open for access file bFile
	set fileContents to read _file
	close access _file
	
	set rooms to paragraphs of fileContents
	set _filtered to {}
	repeat with _item in rooms
		set _s to _item as string
		if _s is not "" and _s does not start with "#" then
			set end of _filtered to _s
		end if
	end repeat
	set rooms to _filtered
	
	set roomCount to (count rooms)
	if roomCount is 0 then
		return "No rooms are defined in the file " & borFilePath & " - exiting."
	end if
	
	my clickStatusMenu("Breakout")
	set _borWin to my findSubWindow(appName, "Breakout")
	if name of _borWin contains "In Progress" then
		return "Breakout rooms already started. Please close them first."
	else
		-- TODO - Here we should create the rooms
	end if
end createBreakoutRooms

on run argv
	set argCount to (count argv)
	if (argCount > 0) then
		set arg to item 1 of argv
	else
		set arg to "roster"
	end if
	if arg is "help" or arg is not in knownCommands then
		return my usageMessage("top")
	else if arg is "reset" then
		return my resetTrackigData()
	end if
	
	my setUpLogFiles()
	if arg is "server" then
		return my runBackendServer()
	end if
	if arg is "dashboard" then
		return my openDashboard()
	end if
	
	my appLogMessage("START " & arg)
	try
		my checkZoomRunning()
		my logMessage("Zoom Version: " & appVersion, logFile)
		my checkZoomMeetingRunning()
		my startParticipantWindow()
		if arg is "roster" then
			my generateRoster()
		else if arg is "hands" then
			my generateFilteredRoster("Hand raised")
		else if arg is "camera_off" then
			my generateFilteredRoster("Video off")
		else if arg is "camera_on" then
			my generateFilteredRoster("Video on")
		else if arg is "phone" then
			my generateFilteredRoster("Telephone")
		else if arg is "no_audio" then
			my generateFilteredRoster("No Audio")
		else if arg is "muted" then
			my generateFilteredRoster(" muted")
		else if arg is "unmuted" then
			my generateFilteredRoster(" unmuted")
		else if arg is "admit" then
			my letPeopleIn()
		else if arg is "breakout" then
			if argCount is not 2 then
				return my usageMessage("breakout")
			end if
			return my createBreakoutRooms(item 2 of argv)
		end if
	on error errMsg number errNum
		set e_str to "Error: " & errMsg
		my logMessage(e_str, logFile)
		my appLogMessage("ABORT " & arg)
		error e_str number errNum
	end try
	my appLogMessage("END " & arg)
end run
