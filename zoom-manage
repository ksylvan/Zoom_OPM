#!/usr/bin/osascript
(*
@encoding ISO-8859-1 (Mac Roman)

Copyright (c) 2023 Kayvan A. Sylvan

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *)

-- Global properties
property scriptName : "Zoom Manage"
property topLevelDirectory : missing value

-- Zoom Related properties
property appName : "zoom.us"
property appVersion : missing value
property topZoomWindow : "Zoom"
property meetingWindow : "Zoom Meeting"
property participantWindow : missing value

-- These three files are created in the logs/ subdirectory.
-- The pattern of filenames: logs/20231014-log.txt
-- This makes it easy to store and index the logs at a later time.
-- roster.txt is the running log file capturing the roster information.
-- log.txt is the overall log file.
-- filtered.txt is the filtered log file (capturing "Hands Raised", etc.)
property logFile : "log.txt"
property meetingRoster : "roster.txt"
property filteredRoster : "filtered.txt"

-- The FastAPI server should be running at this URL
property trackerURL : "http://localhost:5000"
property batchCount : 50 -- can be set via ZOOM_MANAGE_BATCH_SIZE environment variable

-- Top level commands the script understands
property knownCommands : {Â
	"help", "reset", "roster", "hands", "camera_off", "admit", "server", "dashboard", Â
	"breakout", "camera_off", "camera_on", "phone", "no_audio", "muted", "unmuted", Â
	"rename", "co-host", "host"}

-- zoomRosterDebug uses the ZOOM_DEBUG environment variable.
-- If it is set to true, filtered rosters (like "hands") will be
-- output to the console (stderr) in addition to going in the log.
property zoomRosterDebug : missing value

-- renameParticipantsFile is a mapping of users to rename upon entry to the meeting.
-- If set, we use it in the "roster" command to check for and rename
-- participants. It references the ZOOM_RENAME_FILE environment
property renameParticipantsFile : missing value
property renameMappings : missing value -- the mappings found in the above file

-- useScrollingRoster controls whether to use the new scrolling method for participant gathering
-- This addresses Zoom's virtual scrolling where only visible participants are in the DOM
property useScrollingRoster : missing value

-- Path to cliclick. See https://github.com/BlueM/cliclick
property cliclick : "/opt/homebrew/bin/cliclick"

property environmentDocs: Â
	"Environment Variables:" & linefeed Â
	& "    - ZOOM_DEBUG: Set this to any value to see rosters and filtered lists output on the console." & linefeed Â
	& "    - ZOOM_RENAME_FILE: Path to a file of participant rename mappings. See rename/README.md file for details." & linefeed Â
	& "    - ZOOM_USE_SCROLLING: Set to any value to use scrolling method for gathering all participants (recommended for large meetings)." & linefeed

on usageMessage(section)
	set tid to AppleScript's text item delimiters
	set AppleScript's text item delimiters to ":"
	set path_parts to every text item of ((path to me) as string)
	set AppleScript's text item delimiters to tid
	if section is "top" then
		return linefeed & "Usage: " & (item -1 of path_parts) & " [command]" & linefeed Â
			& "    help - show usage message." & linefeed & linefeed Â
			& "    server - start/stop the backend server. Starts the server in its own terminal." & linefeed Â
			& "    dashboard - open the Zoom Meeting Tracker dashboard." & linefeed Â
			& "    reset - reset the tracking database." & linefeed & linefeed Â
			& "    roster (default action) - get current roster." & linefeed Â
			& linefeed Â
			& "    hands - get the current hands raised." & linefeed Â
			& "    camera_off - get the list of camera off participants." & linefeed Â
			& "    camera_on - get the list of participants who are on video." & linefeed Â
			& "    no_audio - get the list of participants not connected to audio." & linefeed Â
			& "    muted - get the list of participants who are muted." & linefeed Â
			& "    unmuted - get the list of participants who are unmuted." & linefeed Â
			& "    phone - get the list of participants dialing in by phone." & linefeed Â
			& linefeed Â
			& "    admit - admit everyone in the Waiting Room." & linefeed Â
			& "    breakout - create a set of named breakout rooms." & linefeed Â
			& linefeed Â
			& "    rename - rename a participant." & linefeed Â
			& "    co-host - make a participant a co-host." & linefeed Â
			& "    host - make a participant the meeting host (NOTE: You will not be Host or Co-Host)" & linefeed Â
			& linefeed & environmentDocs
	else if section is "breakout" then
		return linefeed & "Usage: " & (item -1 of path_parts) & " breakout [create | get | help] filename" & linefeed Â
			& "    help - print the breakout related help message." & linefeed Â
			& "    create - Opens up the named file and creates the rooms named there." & linefeed Â
			& "    get - Get the named rooms and write them into filename." & linefeed
	else if section is "rename" then
		return linefeed & "Usage: " & (item -1 of path_parts) & " rename 'Original Name' 'New Name'" & linefeed
	else if section is "co-host" then
		set more to "    You can also withdraw co-host by re-running the command with the \"(Co-host)\" name." & linefeed
		return linefeed & "Usage: " & (item -1 of path_parts) & " co-host 'Participant Name'" & linefeed & more
	else if section is "host" then
		set more to "    Warning: Once you do this, you are no longer Host or Co-Host." & linefeed
		return linefeed & "Usage: " & (item -1 of path_parts) & " host 'Participant Name'" & linefeed & more
	else if section is "server" then
		set more to "    The start action launches the server in its own Terminal window." & linefeed
		return linefeed & "Usage: " & (item -1 of path_parts) & " server [start|stop]" & linefeed & more
	end if
end usageMessage

on todayYMD()
	-- Return the current date in the format YYYYMMDD.
	set [_day, _month, _year] to [day, month, year] of (current date)
	set _month to _month * 1 --> 3
	set _month to text -1 thru -2 of ("0" & _month) --> "03"
	set _day to text -1 thru -2 of ("0" & _day)
	set result to _year & _month & _day
	return result
end todayYMD

on setUpLogFiles()
	-- setUpLogFiles handler:
	-- Creates a folder called "logs" in the same directory as the program if it does not already exist.
	-- It then creates two files, logFile and meetingRoster, in the logs folder, with a prefix of the current date.
	tell application "Finder"
		set _currentDirectory to container of (path to me)
		if not (exists folder "logs" of _currentDirectory) then
			make new folder at _currentDirectory with properties {name:"logs"}
		end if
	end tell
	set _currentDirectory to POSIX path of (_currentDirectory as text)
	set _prefix to my todayYMD()
	set topLevelDirectory to _currentDirectory
	set logFile to POSIX file (topLevelDirectory & "logs/" & _prefix & "-" & logFile)
	set meetingRoster to POSIX file (topLevelDirectory & "logs/" & _prefix & "-" & meetingRoster)
	set filteredRoster to POSIX file (topLevelDirectory & "logs/" & _prefix & "-" & filteredRoster)
	my setupEnvVariables()
end setUpLogFiles

on setupEnvVariables()
	-- zoomRosterDebug is false if ZOOM_DEBUG is not set
	set zoomRosterDebug to do shell script "echo ${ZOOM_DEBUG:-unset}"
	set zoomRosterDebug to (zoomRosterDebug is not "unset") -- set to false or true
	-- batchCount is set to value of ZOOM_MANAGER_BATCH_SIZE (50 if not set)
	set batchCount to do shell script "echo ${ZOOM_MANAGE_BATCH_SIZE:-" & batchCount & "}"
	-- renameParticipantsFile points to a mapping file of old to new names with "->" in between them.
	set renameParticipantsFile to do shell script "echo ${ZOOM_RENAME_FILE:-}"
	if renameParticipantsFile is "" then set renameParticipantsFile to missing value
	-- useScrollingRoster enables the new scrolling method for participant gathering
	set useScrollingRoster to do shell script "echo ${ZOOM_USE_SCROLLING:-unset}"
	set useScrollingRoster to (useScrollingRoster is not "unset") -- set to false or true
end setupEnvVariables

on filterFileContents(fileLines)
	-- Given a set of fileLines (usually gathered from "paragraphs of fileContents" idiom)
	-- Return a new list, ignoring all empty lines and lines starting with "#"
	set _filtered to {}
	repeat with _item in fileLines
		set _s to _item as string
		if _s is not "" and _s does not start with "#" then
			if _s starts with "\\" then set _s to text 2 through -1 of _s
			set end of _filtered to _s
		end if
	end repeat
	return _filtered
end filterFileContents

on splitText(theText, theDelimiter)
    set oldDelimiters to AppleScript's text item delimiters
    set AppleScript's text item delimiters to theDelimiter
    set textItems to every text item of theText
    set AppleScript's text item delimiters to oldDelimiters -- Restore the original delimiters
    return textItems
end splitText

on loadRenameMappings()
	if renameParticipantsFile is missing value then return
	if not renameParticipantsFile starts with "/" then
		set renameParticipantsFile to topLevelDirectory & renameParticipantsFile
	end if
	tell application "System Events"
		if (not (exists file renameParticipantsFile)) then
			error ("Missing ZOOM_RENAME_FILE file: " & renameParticipantsFile) number -1
		end if
		set _size to size of (info for POSIX file renameParticipantsFile)
		if _size is 0 then
			error ("Empty ZOOM_RENAME_FILE file: " & renameParticipantsFile) number -2
		end if
	end tell
	set _rFile to POSIX file renameParticipantsFile
	set _file to open for access file _rFile
	set fileContents to read _file
	close access _rFile

	set mappings to my filterFileContents(paragraphs of fileContents)
	set renameMappings to {}
	repeat with _item in mappings
		set end of renameMappings to my splitText(_item, "->")
	end repeat
end loadRenameMappings

on lookupRenaming(oldName)
	if renameMappings is missing value then return
	repeat with _i in renameMappings
		if item 1 of _i as text is oldName as text then return _i
	end repeat
	return missing value
end lookupRenaming

on formatDateTime(theDateTime)
	(*
	This code takes a date and time as input and formats it into a string in the form of MM/DD/YYYY HH:MM:SS.
	It does this by extracting the day, month, year, hours, minutes, and seconds from the input and
	adding a leading zero if necessary.
	*)
	set [_day, _month, _year, _hours, _minutes, _seconds] to [day, month, year, hours, minutes, seconds] of theDateTime
	set _month to _month * 1 --> 3
	set _month to text -1 thru -2 of ("0" & _month) --> "03"
	set _day to text -1 thru -2 of ("0" & _day)
	set _hours to text -1 thru -2 of ("0" & _hours) --> "05"
	set _minutes to text -1 thru -2 of ("0" & _minutes)
	set _seconds to text -1 thru -2 of ("0" & _seconds)
	set result to _month & "/" & _day & "/" & _year & " " & _hours & ":" & _minutes & ":" & _seconds
	return result
end formatDateTime

on appendToFile(theFile, message, logToConsole)
	-- Write the message to theFile. logToConsole is a boolean indicating whether to log to console.
	write message & linefeed to theFile starting at eof
	if logToConsole then log message
end appendToFile

on logMessage(message, filePath)
	-- Usage:
	-- set logFilePath to (path to desktop as string) & "logfile.txt" -- Path to the log file
	-- my logMessage("This is a log message.", logFilePath)
	try
		-- Open the log file for writing, creating it if it doesn't exist
		set _log to open for access file filePath with write permission

		-- Construct the log entry
		set logEntry to (my formatDateTime(current date)) & " " & message

		-- Write the log entry to the file
		my appendToFile(_log, logEntry, false)

		-- Close the log file
		close access _log

	on error errMsg number errNum
		-- If an error occurs, close the log file (if it's open)
		try
			close access _log
		end try
		-- Optionally, report the error in some way
		set _msg to "Error: " & errMsg & " (" & errNum & ")"
		log _msg
		display dialog _msg
	end try
end logMessage

on checkZoomRunning()
	tell application "System Events"
		set _isRunning to (name of every process) contains appName
	end tell
	if not _isRunning then
		tell application appName to activate
		delay 1.0
	end if
	set appVersion to version of application appName
end checkZoomRunning

on findStatusMenu(candidateSubstrings)
	-- Find a status menu of Zoom that contains any of the candidate substrings
	-- candidateSubstrings: can be a single string (backward compatibility) or list of strings
	-- For backward compatibility, this version doesn't include debug flag
	return my findStatusMenuWithDebug(candidateSubstrings, false)
end findStatusMenu

on findStatusMenuWithDebug(candidateSubstrings, debugFlag)
	-- Find a status menu of Zoom that contains any of the candidate substrings
	-- candidateSubstrings: can be a single string or list of strings to search for
	-- debugFlag: boolean to enable debug output of discovered menu names

	-- Handle parameter types: if candidateSubstrings is a string, convert to list
	if class of candidateSubstrings is string then
		set candidateList to {candidateSubstrings}
	else
		set candidateList to candidateSubstrings
	end if

	set _ret to missing value
	set discoveredMenus to {}

	tell application "System Events" to tell process appName
		-- First, try to find at the top level
		set menuItems to every menu item of menu 1 of menu bar 2
		repeat with m in menuItems
			if (exists name of m) then
				set menuName to name of m
				set end of discoveredMenus to menuName
				-- Check if this menu item matches any of our candidates
				repeat with candidate in candidateList
					if menuName contains (candidate as string) then
						set _ret to m
						exit repeat
					end if
				end repeat
				if _ret is not missing value then exit repeat
			end if
		end repeat

		-- If not found at first level, recursively inspect sub-menus
		if _ret is missing value then
			repeat with m in menuItems
				if (exists name of m) then
					set menuName to name of m
					-- Look for common sub-menu containers like "More", "Options", etc.
					if menuName contains "More" or menuName contains "Options" or menuName contains "â¦" then
						try
							-- Try to access the sub-menu
							click m
							delay 0.5
							-- Check if a menu appears
							if exists menu 1 of m then
								set subMenuItems to every menu item of menu 1 of m
								repeat with subM in subMenuItems
									if (exists name of subM) then
										set subMenuName to name of subM
										set end of discoveredMenus to (menuName & " -> " & subMenuName)
										-- Check if this sub-menu item matches any of our candidates
										repeat with candidate in candidateList
											if subMenuName contains (candidate as string) then
												set _ret to subM
												exit repeat
											end if
										end repeat
										if _ret is not missing value then exit repeat
									end if
								end repeat
								-- Close the sub-menu by pressing escape
								key code 53 -- ESC key
								delay 0.2
							end if
						on error errMsg
							-- Sub-menu access failed, continue to next menu item
							key code 53 -- ESC key to close any open menus
							delay 0.2
						end try
						if _ret is not missing value then exit repeat
					end if
				end if
			end repeat
		end if
	end tell

	-- If debug flag is enabled and lookup failed, dump discovered menu names
	if debugFlag and _ret is missing value then
		set debugOutput to "=== DEBUG: Menu Discovery Failed ===" & linefeed
		set debugOutput to debugOutput & "Searched for candidates: "
		repeat with candidate in candidateList
			set debugOutput to debugOutput & "'" & (candidate as string) & "' "
		end repeat
		set debugOutput to debugOutput & linefeed & "Discovered menus:" & linefeed
		repeat with menuName in discoveredMenus
			set debugOutput to debugOutput & "  - " & (menuName as string) & linefeed
		end repeat
		set debugOutput to debugOutput & "=== END DEBUG ===" & linefeed
		my logMessage(debugOutput, logFile)
		log debugOutput
	end if

	return _ret
end findStatusMenuWithDebug

on clickStatusMenu(nameSubstring)
	-- Click a menu item in status menu. Returns true if done, false otherwise.
	-- If direct click fails, automatically open the "More" menu item, then attempt breakout lookup again.
	-- Ensure previous behavior for 5.17.x continues to work by guarding with `exists` checks.

	tell application "System Events" to tell process appName
		-- First attempt: try direct lookup
		set m to my findStatusMenu(nameSubstring)
		if m is not missing value then
			click m
			delay 1
			return true
		end if

		-- Fallback: if direct lookup failed, try looking in "More" menu
		set moreMenuItem to missing value
		set menuItems to {}

		-- Guard with exists check for 5.17.x compatibility
		if exists menu bar 2 then
			if exists menu 1 of menu bar 2 then
				set menuItems to every menu item of menu 1 of menu bar 2
			end if
		end if

		-- Look for "More" menu item
		repeat with menuItem in menuItems
			if exists name of menuItem then
				set menuName to name of menuItem
				if menuName contains "More" or menuName contains "â¦" then
					set moreMenuItem to menuItem
					exit repeat
				end if
			end if
		end repeat

		-- If "More" menu found, try to access it and look for the target item
		if moreMenuItem is not missing value then
			try
				-- Click "More" to open submenu
				click moreMenuItem
				delay 0.5

				-- Guard with exists check for submenu
				if exists menu 1 of moreMenuItem then
					set subMenuItems to every menu item of menu 1 of moreMenuItem
					repeat with subMenuItem in subMenuItems
						if exists name of subMenuItem then
							set subMenuName to name of subMenuItem
							if subMenuName contains nameSubstring then
								-- Found the target item in submenu
								click subMenuItem
								delay 1
								return true
							end if
						end if
					end repeat
				end if

				-- Close the "More" menu if target not found
				key code 53 -- ESC key
				delay 0.2

			on error errMsg
				-- If accessing "More" menu fails, close any open menus
				key code 53 -- ESC key
				delay 0.2
			end try
		end if
	end tell

	-- Return false if neither direct nor fallback approach succeeded
	return false
end clickStatusMenu

on enableParticipantsWindow()
	(*
	This code is used to click the "Manage Participants" menu item of the status menu bar.
	A delay of 1 second is added after the click.
	*)
	my clickStatusMenu("Participants")
	my logMessage("Participants panel started.", logFile)
end enableParticipantsWindow

on findSubWindow(nameOfApp, subWinName)
	-- Look for a sub-window of nameOfApp whose name contains subWinName
	tell application "System Events" to tell process nameOfApp
		set _wins to windows
		set _ret to missing value
		repeat with w in _wins
			if name of w starts with subWinName then
				set _ret to w
				exit repeat
			end if
		end repeat
	end tell
	return _ret
end findSubWindow

on getCurrentParticipantsWindow()
	-- Dynamically find the current participants window (handles changing participant counts)
	-- This function is called repeatedly and must handle stale window references
	-- ALWAYS gets a fresh window reference to avoid stale references
	try
		tell application "System Events" to tell process appName
			-- First try to find participants panel embedded in main meeting window
			-- Use dynamic window reference, not cached
			set allWindows to windows
			repeat with mainWin in allWindows
				try
					set mainWinName to name of mainWin
					if mainWinName = meetingWindow then
						if exists scroll area 1 of mainWin then
							-- Validate that we can actually access the scroll area
							try
								set testAccess to scroll area 1 of mainWin
								tell scroll area 1 of mainWin
									if exists outline 1 then
										set testOutline to outline 1
										return mainWin -- Participants panel is embedded in main window
									end if
								end tell
							on error
								-- Fall through to separate window search
							end try
						end if
					end if
				on error
					-- Continue searching
				end try
			end repeat

			-- Look for separate participants window - search dynamically each time, never cache
			set _wins to windows -- Get fresh window list
			repeat with w in _wins
				try
					set winName to name of w
					if winName starts with "Participants" then
						-- Validate that we can actually access this window's content
						if exists scroll area 1 of w then
							tell scroll area 1 of w
								if exists outline 1 then
									set testAccess to outline 1
									return w -- Found accessible participants window
								end if
							end tell
						end if
					end if
				on error
					-- This window is not accessible, continue searching
				end try
			end repeat
		end tell
	on error errMsg
		my logMessage("Error in getCurrentParticipantsWindow: " & errMsg, logFile)
	end try

	-- If we get here, no accessible participants window was found
	return missing value
end getCurrentParticipantsWindow

on findParticipantsWindow()
	-- Deprecated: This function is replaced by getCurrentParticipantsWindow()
	-- Kept for backward compatibility but should not be used
	tell application "System Events" to tell process appName
		if exists scroll area 1 of window meetingWindow then
			set participantWindow to window meetingWindow -- Participants panel.
		else
			set participantWindow to my findSubWindow(appName, "Participants")
		end if
	end tell
end findParticipantsWindow

on startParticipantWindow()
	tell application "System Events" to tell process appName
		try
			set currentParticipantWindow to my getValidParticipantsWindow()
		on error
			my enableParticipantsWindow() -- participant window started
		end try
	end tell
end startParticipantWindow

on checkZoomMeetingRunning()
	-- Make sure we are in a Zoom meeting
	tell application "System Events" to tell process appName
		set _startMeetingMenu to my findStatusMenu("Join a Meeting")
		if _startMeetingMenu is not missing value then
			set _msg to "The " & scriptName & " application needs a Zoom Meeting. Please join a meeting first."
			error (_msg) number -3
		end if
	end tell
end checkZoomMeetingRunning

on appLogMessage(message)
	my logMessage("=== " & scriptName & ": " & message, logFile)
end appLogMessage

on resetTrackingData()
	do shell script "curl -X POST " & trackerURL & "/reset"
end resetTrackingData

on replaceText(theText, searchStr, replacementStr)
	set theText to theText as text
	if theText does not contain searchStr then
		return theText -- return the original string if it doesn't contain the search string
	end if
	set oldDelims to AppleScript's text item delimiters -- save old delimiters
	set AppleScript's text item delimiters to the searchStr
	set theTextItems to every text item of theText
	set AppleScript's text item delimiters to the replacementStr
	set theText to theTextItems as string
	set AppleScript's text item delimiters to oldDelims -- restore old delimiters
	return theText
end replaceText

on trackList(_nameList, apiEndpoint)
	if (count _nameList) is 0 then
		return
	end if
	set _sanitized to {}
	repeat with _p in _nameList
		set _p to my replaceText(_p, "'", "-") -- Hack for people with single-quotes in their name
		set _sanitized to _sanitized & {_p}
	end repeat
	set cmd to "curl -X PUT -H 'Content-Type: application/json' -d ' ["
	set qList to {}
	repeat with n in _sanitized
		set qList to qList & {"\"" & n & "\""}
	end repeat
	set _tid to AppleScript's text item delimiters
	set AppleScript's text item delimiters to ","
	set cmd to cmd & (qList as string) & "]' " & trackerURL & apiEndpoint
	set AppleScript's text item delimiters to _tid
	do shell script cmd
	-- log cmd
end trackList

on trackListBatched(_nameList, apiEndpoint)
	set _nameCount to count _nameList
	repeat with i from 1 to _nameCount by batchCount
		set endIndex to i + batchCount - 1
		if endIndex > _nameCount then set endIndex to _nameCount
		my trackList(items i thru endIndex of _nameList, apiEndpoint)
	end repeat
end trackListBatched

on trackJoined(_nameList)
	my trackListBatched(_nameList, "/joined_list")
end trackJoined

on trackWaiting(_nameList)
	my trackListBatched(_nameList, "/waiting_list")
end trackWaiting

on runBackendServer()
	-- check if the server is already running
	set serverRunning to false
	try
		set jsonOutput to do shell script "curl -X GET " & trackerURL & "/health -H 'accept: application/json'"
		if jsonOutput starts with "{" then set serverRunning to true
	on error errMessage number errNum
		error errMessage number errNum
	end try
	if serverRunning then
		error "Server is already running. " & jsonOutput number -1
	end if
	set titleString to "\\033]0;" & scriptName & " Backend Server\\007"
	set cmd to "echo -n -e \"" & titleString & "\";cd " & topLevelDirectory & "backend; . ../.venv/bin/activate; ./server.py; exit"
	do shell script "open -a Terminal " & topLevelDirectory
	tell application "Terminal"
		activate
		do script cmd in window 1
	end tell
end runBackendServer

on killBackendServer()
	tell application "System Events"
		set _title to scriptName & " Backend Server"
		set _win to missing value
		try
			set _win to first window of application process "Terminal" whose name contains _title
		end try
		if _win is missing value then
			log "No backend server window found. Nothing to do."
			return
		end if
		click UI Element 2 of _win
		delay 0.2
		set {_x, _y} to position of _win
		my clickMouse(_x, _y)
		keystroke "\r"
		my clickMouse(_x, _y)
		keystroke "\r"
	end tell
end killBackendServer

on openDashboard()
	do shell script "open " & topLevelDirectory & "frontend/index.html"
end openDashboard

on writeToRoster(message, filePath)
	-- Usage:
	-- set logFilePath to (path to desktop as string) & "roster.txt" -- Path to the roster file
	-- my writeTeRoster("John Smith", logFilePath)
	try
		-- Open the log file for writing, creating it if it doesn't exist
		set _log to open for access file filePath with write permission
		my appendToFile(_log, message, zoomRosterDebug)
		-- Close the log file
		close access _log
	on error errMsg number errNum
		-- If an error occurs, close the log file (if it's open)
		try
			close access _log
		end try
		-- Optionally, report the error in some way
		set _msg to "Error: " & errMsg & " (" & errNum & ")"
		log _msg
		display dialog _msg
	end try
end writeToRoster

on writeToRosterPart(namesList, spacesPrefix)
	-- Write a list of names to the roster.txt file
	-- prepend each with the spacesPrefix
	if (count namesList) is 0 then return
	set i to 1
	repeat with n in namesList
		my writeToRoster(spacesPrefix & i & ". " & n, meetingRoster)
		set i to i + 1
	end repeat
end writeToRosterPart

on getValidParticipantsWindow()
	-- Helper function to get a valid participants window reference
	-- Re-fetches the window reference to handle dynamic name changes
	-- This function ALWAYS gets a fresh window reference to avoid stale references

	set maxRetries to 3
	set retryCount to 0

	repeat while retryCount < maxRetries
		set retryCount to retryCount + 1

		try
			set windowRef to my getCurrentParticipantsWindow()
			if windowRef is missing value then
				error "Could not find participants window" number -1728
			end if

			-- Test accessibility by trying to access its scroll area
			tell application "System Events" to tell process appName
				tell windowRef
					-- Try to access the scroll area and get a sample to verify it's working
					set testAccess to scroll area 1
					tell outline 1 of scroll area 1
						set testSample to get value of static text of UI element of rows
					end tell
				end tell
			end tell

			-- If we get here, the window is accessible
			return windowRef

		on error errMsg number errNum
			if retryCount < maxRetries then
				my logMessage("Window access attempt " & retryCount & " failed: " & errMsg & " - retrying in 0.5s", logFile)
				delay 0.5
			else
				my logMessage("All window access attempts failed after " & maxRetries & " retries: " & errMsg, logFile)
				error "Participants window is not accessible after retries: " & errMsg number errNum
			end if
		end try
	end repeat
end getValidParticipantsWindow

on safeWindowOperation(operationName, windowRef)
	-- Safely execute operations on the participants window with retry logic
	-- This function handles stale window references by refreshing them
	set maxRetries to 2
	set retryCount to 0

	repeat while retryCount < maxRetries
		set retryCount to retryCount + 1

		try
			-- Test if the window is still accessible by checking content access
			tell application "System Events" to tell process appName
				tell windowRef
					-- Verify both scroll area and outline accessibility
					if exists scroll area 1 then
						tell scroll area 1
							if exists outline 1 then
								set testAccess to outline 1
								-- Window is still accessible
							else
								error "Outline not accessible in participants window" number -1728
							end if
						end tell
					else
						error "Scroll area not accessible in participants window" number -1728
					end if
				end tell
			end tell

			-- If we get here, the window is still accessible
			return windowRef

		on error errMsg number errNum
			if retryCount < maxRetries then
				my logMessage("Window operation '" & operationName & "' failed (attempt " & retryCount & "): " & errMsg & " - refreshing window", logFile)
				-- Get a fresh window reference
				try
					set windowRef to my getValidParticipantsWindow()
				on error refreshErr
					my logMessage("Failed to refresh window for operation '" & operationName & "': " & refreshErr, logFile)
					error refreshErr
				end try
			else
				my logMessage("Window operation '" & operationName & "' failed after " & maxRetries & " attempts: " & errMsg, logFile)
				error "Window operation failed after retries: " & errMsg number errNum
			end if
		end try
	end repeat

	return windowRef
end safeWindowOperation

on verifyWindowAccess(windowRef, operationName)
	-- Quick verification that a window reference is still valid
	-- Returns true if accessible, false otherwise
	try
		tell application "System Events" to tell process appName
			tell windowRef
				-- Quick test - just check if scroll area exists
				set testExists to exists scroll area 1
				if testExists then
					return true
				else
					my logMessage("Window verification failed for " & operationName & ": scroll area not found", logFile)
					return false
				end if
			end tell
		end tell
	on error errMsg
		my logMessage("Window verification failed for " & operationName & ": " & errMsg, logFile)
		return false
	end try
end verifyWindowAccess

on getAllParticipantsWithScrolling()
	-- This function handles Zoom's virtual scrolling by collecting participants in a sliding window
	-- Returns the same format as the original single-call method
	set allCollectedNames to {}
	set seenNames to {}
	set maxIterations to 150 -- Increased further for very large meetings
	set iteration to 0
	set consecutiveEmptyIterations to 0
	set maxConsecutiveEmpty to 8 -- Allow more empty iterations to handle dynamic changes
	set consecutiveUnchangedScrolls to 0
	set maxUnchangedScrolls to 3 -- If scroll position doesn't change 3 times, we're at bottom
	set lastCollectedCount to 0
	set stableCountIterations to 0

	my logMessage("Using enhanced scrolling method to gather all participants", logFile)

	tell application "System Events" to tell process appName
		-- Get a valid participants window reference with error handling
		set currentParticipantWindow to my getValidParticipantsWindow()

		-- First, ensure we're focused on the participants window
		set frontmost to true
		click currentParticipantWindow
		delay 0.5

		-- Now focus specifically on the participants list within the window
		tell currentParticipantWindow
			-- TAB twice to select the participants list
			keystroke tab
			delay 0.3
			keystroke tab
			delay 0.3
		end tell

		-- Click on the outline element and scroll to top using smart detection
		tell outline 1 of scroll area 1 of currentParticipantWindow
			-- Click on the outline to ensure it has focus
			click
			delay 0.2
		end tell

		-- Enhanced scroll to top - multiple strategies to ensure we reach the absolute top
		tell currentParticipantWindow
			set pageUpAttempts to 0
			set maxPageUpAttempts to 100 -- Increased limit for very large meetings
			set previousNames to {}
			set stableTopIterations to 0
			set maxStableIterations to 3 -- Require multiple stable iterations to confirm we're at top

			-- Scroll to top using PAGE UP method only (CMD+HOME doesn't work in Zoom)
			repeat while pageUpAttempts < maxPageUpAttempts
				-- Get current visible names before PAGE UP
				tell outline 1 of scroll area 1 of currentParticipantWindow
					set currentNames to get value of static text of UI element of rows
				end tell

				-- If the names are the same as before, we haven't moved
				if currentNames is equal to previousNames then
					set stableTopIterations to stableTopIterations + 1
					if pageUpAttempts > 0 and stableTopIterations >= maxStableIterations then
						my logMessage("Confirmed at top of list after " & pageUpAttempts & " PAGE UP commands (" & stableTopIterations & " stable iterations)", logFile)
						exit repeat
					end if
				else
					set stableTopIterations to 0 -- Reset counter if content changed
				end if

				set previousNames to currentNames
				set pageUpAttempts to pageUpAttempts + 1
				key code 116 -- PAGE UP key
				delay 0.15 -- Slightly faster delay for efficiency
			end repeat

			if pageUpAttempts >= maxPageUpAttempts then
				my logMessage("Warning: Reached max PAGE UP attempts (" & maxPageUpAttempts & ") - assuming at top", logFile)
			end if

			-- Final verification: try a few more PAGE UPs to be absolutely sure
			set finalVerificationAttempts to 0
			repeat while finalVerificationAttempts < 5
				tell outline 1 of scroll area 1 of currentParticipantWindow
					set beforeFinalUp to get value of static text of UI element of rows
				end tell
				key code 116 -- PAGE UP key
				delay 0.1
				tell outline 1 of scroll area 1 of currentParticipantWindow
					set afterFinalUp to get value of static text of UI element of rows
				end tell
				if beforeFinalUp is equal to afterFinalUp then
					-- No change, we're definitely at the top
					exit repeat
				end if
				set finalVerificationAttempts to finalVerificationAttempts + 1
			end repeat

			my logMessage("Completed enhanced scroll to top with " & (pageUpAttempts + finalVerificationAttempts) & " total PAGE UP attempts", logFile)
		end tell

		repeat while iteration < maxIterations
			set iteration to iteration + 1
			set newNamesFound to false

			-- Refresh window reference periodically to handle dynamic changes
			if (iteration mod 10 = 0) then -- More frequent refresh
				try
					set currentParticipantWindow to my safeWindowOperation("periodic_refresh_" & iteration, currentParticipantWindow)
				on error errMsg
					my logMessage("Periodic window refresh failed at iteration " & iteration & ": " & errMsg, logFile)
					-- Try to get a completely fresh window reference
					try
						set currentParticipantWindow to my getValidParticipantsWindow()
						my logMessage("Successfully obtained fresh window reference at iteration " & iteration, logFile)
					on error errMsg2
						my logMessage("Failed to get fresh window reference: " & errMsg2, logFile)
						exit repeat -- Exit if we can't get a valid window
					end try
				end try
			end if

			-- Store current visible names before processing to detect scroll position changes
			try
				-- First verify the window is still accessible
				set currentParticipantWindow to my safeWindowOperation("get_names_" & iteration, currentParticipantWindow)
				tell outline 1 of scroll area 1 of currentParticipantWindow
					set currentVisibleNames to get value of static text of UI element of rows
				end tell
			on error errMsg
				my logMessage("Error accessing participants list at iteration " & iteration & ": " & errMsg, logFile)
				-- Try to get a completely fresh window reference and continue
				try
					set currentParticipantWindow to my getValidParticipantsWindow()
					tell outline 1 of scroll area 1 of currentParticipantWindow
						set currentVisibleNames to get value of static text of UI element of rows
					end tell
					my logMessage("Successfully recovered window access at iteration " & iteration, logFile)
				on error errMsg2
					my logMessage("Failed to recover window access: " & errMsg2, logFile)
					exit repeat -- Exit if we can't access the window
				end try
			end try

			-- Process each visible name
			try
				tell outline 1 of scroll area 1 of currentParticipantWindow
					repeat with participantName in currentVisibleNames
						set participantName to participantName as string
						-- Skip empty entries that appear due to virtual scrolling
						if participantName is not "" and participantName is not in seenNames then
							set end of allCollectedNames to participantName
							set end of seenNames to participantName
							set newNamesFound to true
						end if
					end repeat
				end tell
			on error errMsg
				my logMessage("Error processing participants at iteration " & iteration & ": " & errMsg, logFile)
				-- Continue to next iteration
			end try

			-- Track consecutive empty iterations for more robust termination
			if newNamesFound then
				set consecutiveEmptyIterations to 0
				set consecutiveUnchangedScrolls to 0 -- Reset scroll counter when we find new names
				-- Log progress every 10 iterations or when significant progress is made
				if (iteration mod 10 = 0) or ((count allCollectedNames) mod 50 = 0) then
					my logMessage("Progress: Found new participants in iteration " & iteration & " (total: " & (count allCollectedNames) & ")", logFile)
				end if
			else
				set consecutiveEmptyIterations to consecutiveEmptyIterations + 1
				my logMessage("No new participants in iteration " & iteration & " (consecutive empty: " & consecutiveEmptyIterations & ")", logFile)
			end if

			-- Check if participant count has stabilized (important for dynamic meetings)
			set currentCount to count allCollectedNames
			if currentCount = lastCollectedCount then
				set stableCountIterations to stableCountIterations + 1
			else
				set stableCountIterations to 0
				set lastCollectedCount to currentCount
			end if

			-- Multiple termination conditions for robustness
			set shouldTerminate to false
			set terminationReason to ""

			-- Condition 1: Too many consecutive empty iterations
			if consecutiveEmptyIterations >= maxConsecutiveEmpty then
				set shouldTerminate to true
				set terminationReason to "Reached " & maxConsecutiveEmpty & " consecutive empty iterations"
			end if

			-- Condition 2: Scroll position hasn't changed for multiple attempts
			if consecutiveUnchangedScrolls >= maxUnchangedScrolls then
				set shouldTerminate to true
				set terminationReason to "Scroll position unchanged for " & maxUnchangedScrolls & " attempts - reached bottom"
			end if

			-- Condition 3: Participant count has been stable for many iterations (meeting is stable)
			if stableCountIterations >= 5 and consecutiveEmptyIterations >= 3 then
				set shouldTerminate to true
				set terminationReason to "Participant count stable for " & stableCountIterations & " iterations with " & consecutiveEmptyIterations & " empty - list complete"
			end if

			if shouldTerminate then
				my logMessage(terminationReason & " after " & iteration & " total iterations", logFile)
				exit repeat
			end if

			-- Store names before scrolling to detect if scroll actually moved content
			set namesBeforeScroll to currentVisibleNames

			-- Scroll down to see more participants - send PAGE DOWN to the participants window
			try
				-- Verify window is accessible before scrolling
				set currentParticipantWindow to my safeWindowOperation("scroll_" & iteration, currentParticipantWindow)
				tell currentParticipantWindow
					key code 121 -- PAGE DOWN key
				end tell
				delay 0.5 -- Allow UI to update
			on error errMsg
				my logMessage("Error scrolling at iteration " & iteration & ": " & errMsg, logFile)
				-- Try to refresh window reference and scroll again
				try
					set currentParticipantWindow to my getValidParticipantsWindow()
					tell currentParticipantWindow
						key code 121 -- PAGE DOWN key
					end tell
					delay 0.5
					my logMessage("Successfully recovered scrolling at iteration " & iteration, logFile)
				on error errMsg2
					my logMessage("Failed to recover scrolling: " & errMsg2, logFile)
					exit repeat -- Exit if we can't scroll
				end try
			end try

			-- Check if scrolling actually changed the content
			try
				tell outline 1 of scroll area 1 of currentParticipantWindow
					set namesAfterScroll to get value of static text of UI element of rows
				end tell
			on error errMsg
				my logMessage("Error checking scroll result at iteration " & iteration & ": " & errMsg, logFile)
				-- Try once more with refreshed window reference
				try
					set currentParticipantWindow to my getValidParticipantsWindow()
					tell outline 1 of scroll area 1 of currentParticipantWindow
						set namesAfterScroll to get value of static text of UI element of rows
					end tell
				on error errMsg2
					my logMessage("Failed to recover scroll check: " & errMsg2, logFile)
					set namesAfterScroll to namesBeforeScroll -- Assume no change
				end try
			end try

			-- Enhanced scroll detection - compare both content and count
			set scrollContentChanged to (namesBeforeScroll is not equal to namesAfterScroll)
			set scrollCountChanged to ((count namesBeforeScroll) ­ (count namesAfterScroll))

			if not scrollContentChanged and not scrollCountChanged then
				set consecutiveUnchangedScrolls to consecutiveUnchangedScrolls + 1
				my logMessage("Scroll position unchanged in iteration " & iteration & " (consecutive: " & consecutiveUnchangedScrolls & ") - may be at bottom", logFile)
			else
				set consecutiveUnchangedScrolls to 0
				if scrollContentChanged then
					my logMessage("Scroll content changed in iteration " & iteration, logFile)
				end if
				if scrollCountChanged then
					my logMessage("Scroll count changed from " & (count namesBeforeScroll) & " to " & (count namesAfterScroll) & " in iteration " & iteration, logFile)
				end if
			end if

		end repeat

		if iteration >= maxIterations then
			my logMessage("Warning: Reached maximum iterations (" & maxIterations & ") while gathering participants", logFile)
		end if
	end tell

	my logMessage("Enhanced scrolling collection completed: " & (count allCollectedNames) & " total participants collected after " & iteration & " iterations", logFile)

	-- Final validation: take a quick snapshot to verify we didn't miss recent joiners
	if (count allCollectedNames) > 100 then
		my logMessage("Taking final validation snapshot for large meeting", logFile)
		delay 2 -- Brief pause to let any UI settle
		try
			tell application "System Events" to tell process appName
				set currentParticipantWindow to my getValidParticipantsWindow()
				-- Enhanced scroll to top for final validation
				try
					tell currentParticipantWindow
						-- Use multiple PAGE UPs with verification
						set validationPageUps to 0
						set previousValidationNames to {}
						repeat while validationPageUps < 10
							tell outline 1 of scroll area 1 of currentParticipantWindow
								set currentValidationNames to get value of static text of UI element of rows
							end tell
							if currentValidationNames is equal to previousValidationNames and validationPageUps > 0 then
								exit repeat -- We're at the top
							end if
							set previousValidationNames to currentValidationNames
							key code 116 -- PAGE UP
							delay 0.2
							set validationPageUps to validationPageUps + 1
						end repeat
						my logMessage("Final validation used " & validationPageUps & " PAGE UP commands to reach top", logFile)
					end tell
					tell outline 1 of scroll area 1 of currentParticipantWindow
						set validationSample to get value of static text of UI element of rows
						set newInSample to 0
						repeat with sampleName in validationSample
							if (sampleName as string) is not in seenNames and (sampleName as string) is not "" then
								set end of allCollectedNames to (sampleName as string)
								set newInSample to newInSample + 1
							end if
						end repeat
						if newInSample > 0 then
							my logMessage("Validation found " & newInSample & " additional participants - meeting was dynamic during collection", logFile)
						end if
					end tell
				on error errMsg
					my logMessage("Error during final validation: " & errMsg, logFile)
				end try
			end tell
		on error errMsg
			my logMessage("Could not perform final validation: " & errMsg, logFile)
		end try
	end if

	return allCollectedNames
end getAllParticipantsWithScrolling

on generateRoster()
	set _joinedList to {}
	set _waitingList to {}
	set _joinedPrefix to "Joined "
	set _waitingPrefix to "Waiting Room "
	set _notJoinedPrefix to "Not Joined"
	my loadRenameMappings()

	-- Choose method for gathering participants based on environment variable
	set allParticipantNames to {}
	if useScrollingRoster then
		my logMessage("Using scrolling method (forced by ZOOM_USE_SCROLLING)", logFile)
		set allParticipantNames to my getAllParticipantsWithScrolling()
	else
		-- For very large meetings (>200 expected), automatically use scrolling method
		tell application "System Events" to tell process appName
			try
				set currentParticipantWindow to my getValidParticipantsWindow()
				tell outline 1 of scroll area 1 of currentParticipantWindow
					set allParticipantNames to get value of static text of UI element of rows
				end tell
			on error errMsg
				my logMessage("Error accessing participants window in generateRoster: " & errMsg, logFile)
				my logMessage("Falling back to scrolling method due to window access error", logFile)
				set allParticipantNames to my getAllParticipantsWithScrolling()
			end try
			-- If we got fewer than expected and there are many participants, switch to scrolling
			set visibleCount to count allParticipantNames
			my logMessage("Initial scan found " & visibleCount & " visible participants", logFile)

			-- Auto-detect if we need scrolling based on participant window indicators
			set needsScrolling to false
			if visibleCount > 50 then
				set needsScrolling to true
				my logMessage("Large meeting detected (" & visibleCount & " visible) - using scrolling method", logFile)
			end if

			-- Also check if last visible item suggests more content below
			if visibleCount > 10 then
				set lastItem to item -1 of allParticipantNames as string
				if lastItem does not contain "Not Joined" and lastItem does not contain "Breakout" then
					set needsScrolling to true
					my logMessage("Last visible item '" & lastItem & "' suggests more content below - using scrolling method", logFile)
				end if
			end if

			if needsScrolling then
				set allParticipantNames to my getAllParticipantsWithScrolling()
			end if
		end tell
	end if

	-- Process the participant names using the existing logic
	set _num to (count allParticipantNames)
	set _inWaitingList to false
	set _inJoinedList to false
	repeat with i from 1 to _num
		set _pName to item i of allParticipantNames as string
		if _pName starts with _waitingPrefix then
			set _inWaitingList to true
		end if
		if _pName starts with _joinedPrefix then
			set _inWaitingList to false
			set _inJoinedList to true
		end if
		if _pName starts with _notJoinedPrefix then exit repeat
		if (i is 1) and (not _inWaitingList) and (not _inJoinedList) then
			set _joinedList to allParticipantNames
			exit repeat
		end if
		if _inWaitingList then
			if not (_pName starts with _waitingPrefix) then
				set _waitingList to _waitingList & {_pName}
			end if
		else
			if not (_pName starts with _joinedPrefix) then
				set _joinedList to _joinedList & {_pName}
			end if
		end if
	end repeat

	set _intro to "=== " & (my formatDateTime(current date)) & " ==="
	my writeToRoster(_intro, meetingRoster)

	if (count _waitingList) > 0 then
		my writeToRoster("Waiting Room:", meetingRoster)
		my writeToRosterPart(_waitingList, "  ")
		my writeToRoster("Joined:", meetingRoster)
		my writeToRosterPart(_joinedList, "  ")
	else
		my writeToRosterPart(_joinedList, "")
	end if

	set _num to (count _waitingList) + (count _joinedList)
	if _num > 1 then
		set plural to "s"
	else
		set plural to ""
	end if
	set _summary to "=== " & (_num as string) & " participant" & plural Â
		& " " & (my formatDateTime(current date)) & " ==="
	my writeToRoster(_summary, meetingRoster)

	my trackWaiting(_waitingList)
	my trackJoined(_joinedList)

	-- Now, run our rename procedure if needed.
	if renameMappings is missing value then return
	set _renameToDo to {}
	set _candidates to {}
	repeat with _i in renameMappings
		set end of _candidates to item 1 of _i as text
	end repeat
	repeat with participant in _joinedList
		if participant as text is in _candidates then set end of _renameToDo to participant as text
	end repeat
	-- Now we go through each participant in _renameToDo and finish setting up the renaming.
	repeat with _name in _renameToDo
		set _res to my lookupRenaming(_name)
		if _res is not missing value then
			my renameParticipant(item 1 of _res, item 2 of _res, false)
		end if
		delay 0.4
	end repeat
end generateRoster

on joinStringList(_strings)
	set _tid to AppleScript's text item delimiters
	set AppleScript's text item delimiters to ":"
	set _ret to _strings as string
	set AppleScript's text item delimiters to _tid
	return _ret
end joinStringList

on generateFilteredRoster(filterString)
	-- Look for filter strings in the description strings in participants window
	-- This version handles Zoom's virtual scrolling by collecting participants in a sliding window
	set _intro to "=== " & filterString & " " & (my formatDateTime(current date)) & " ==="
	my writeToRoster(_intro, filteredRoster)
	set _num to 0
	set allCollectedMatches to {}
	set seenRowData to {}
	set maxIterations to 150 -- Increased for large meetings
	set iteration to 0
	set consecutiveEmptyIterations to 0
	set maxConsecutiveEmpty to 8 -- Allow more consecutive empty iterations before giving up

	my logMessage("Using scrolling method to gather filtered participants for: " & filterString, logFile)

	tell application "System Events" to tell process appName
		-- Get a valid participants window reference with error handling
		set currentParticipantWindow to my getValidParticipantsWindow()

		-- First, ensure we're focused on the participants window
		set frontmost to true
		click currentParticipantWindow
		delay 0.5

		-- Now focus specifically on the participants list within the window
		tell currentParticipantWindow
			-- TAB twice to select the participants list
			keystroke tab
			delay 0.3
			keystroke tab
			delay 0.3
		end tell

		-- Click on the outline element and scroll to top using smart detection
		tell outline 1 of scroll area 1 of currentParticipantWindow
			-- Click on the outline to ensure it has focus
			click
			delay 0.2
		end tell

		-- Enhanced scroll to top - multiple strategies to ensure we reach the absolute top
		tell currentParticipantWindow
			set pageUpAttempts to 0
			set maxPageUpAttempts to 100 -- Increased limit for very large meetings
			set previousNames to {}
			set stableTopIterations to 0
			set maxStableIterations to 3 -- Require multiple stable iterations to confirm we're at top

			-- Scroll to top using PAGE UP method only (CMD+HOME doesn't work in Zoom)
			repeat while pageUpAttempts < maxPageUpAttempts
				-- Get current visible names before PAGE UP
				tell outline 1 of scroll area 1 of currentParticipantWindow
					set currentNames to get value of static text of UI element of rows
				end tell

				-- If the names are the same as before, we haven't moved
				if currentNames is equal to previousNames then
					set stableTopIterations to stableTopIterations + 1
					if pageUpAttempts > 0 and stableTopIterations >= maxStableIterations then
						my logMessage("Confirmed at top of list after " & pageUpAttempts & " PAGE UP commands for filtered search (" & stableTopIterations & " stable iterations)", logFile)
						exit repeat
					end if
				else
					set stableTopIterations to 0 -- Reset counter if content changed
				end if

				set previousNames to currentNames
				set pageUpAttempts to pageUpAttempts + 1
				key code 116 -- PAGE UP key
				delay 0.15 -- Slightly faster delay for efficiency
			end repeat

			if pageUpAttempts >= maxPageUpAttempts then
				my logMessage("Warning: Reached max PAGE UP attempts (" & maxPageUpAttempts & ") for filtered search - assuming at top", logFile)
			end if

			-- Final verification: try a few more PAGE UPs to be absolutely sure
			set finalVerificationAttempts to 0
			repeat while finalVerificationAttempts < 5
				tell outline 1 of scroll area 1 of currentParticipantWindow
					set beforeFinalUp to get value of static text of UI element of rows
				end tell
				key code 116 -- PAGE UP key
				delay 0.1
				tell outline 1 of scroll area 1 of currentParticipantWindow
					set afterFinalUp to get value of static text of UI element of rows
				end tell
				if beforeFinalUp is equal to afterFinalUp then
					-- No change, we're definitely at the top
					exit repeat
				end if
				set finalVerificationAttempts to finalVerificationAttempts + 1
			end repeat

			my logMessage("Completed enhanced scroll to top for filtered search with " & (pageUpAttempts + finalVerificationAttempts) & " total PAGE UP attempts", logFile)
		end tell

		repeat while iteration < maxIterations
			set iteration to iteration + 1
			set newMatchesFound to false

			-- Refresh window reference periodically to handle dynamic changes
			if (iteration mod 10 = 0) then -- More frequent refresh like in getAllParticipantsWithScrolling
				try
					set currentParticipantWindow to my safeWindowOperation("periodic_refresh_filtered_" & iteration, currentParticipantWindow)
				on error errMsg
					my logMessage("Periodic window refresh failed for filtered search at iteration " & iteration & ": " & errMsg, logFile)
					-- Try to get a completely fresh window reference
					try
						set currentParticipantWindow to my getValidParticipantsWindow()
						my logMessage("Successfully obtained fresh window reference for filtered search at iteration " & iteration, logFile)
					on error errMsg2
						my logMessage("Failed to get fresh window reference for filtered search: " & errMsg2, logFile)
						exit repeat -- Exit if we can't get a valid window
					end try
				end try
			end if

			-- Access participant data with error handling
			try
				-- First verify the window is still accessible
				set currentParticipantWindow to my safeWindowOperation("get_filtered_names_" & iteration, currentParticipantWindow)
				tell outline 1 of scroll area 1 of currentParticipantWindow
					set allParticipantNames to get value of static text of UI element of rows
					set allRows to rows
					set numPart to (count allParticipantNames)
				end tell
			on error errMsg
				my logMessage("Error accessing participants list for filtered search at iteration " & iteration & ": " & errMsg, logFile)
				-- Try to get a completely fresh window reference and continue
				try
					set currentParticipantWindow to my getValidParticipantsWindow()
					tell outline 1 of scroll area 1 of currentParticipantWindow
						set allParticipantNames to get value of static text of UI element of rows
						set allRows to rows
						set numPart to (count allParticipantNames)
					end tell
					my logMessage("Successfully recovered window access for filtered search at iteration " & iteration, logFile)
				on error errMsg2
					my logMessage("Failed to recover window access for filtered search: " & errMsg2, logFile)
					exit repeat -- Exit if we can't access the window
				end try
			end try

			-- Process participants with error handling for each row
			try
				tell outline 1 of scroll area 1 of currentParticipantWindow
					repeat with i from 1 to numPart
						try
						set pName to item i of allParticipantNames as string
						set aRow to item i of allRows

						-- Create a unique identifier for this row to avoid duplicates
						set rowIdentifier to pName & "_" & i

						-- Skip if we've already processed this row data
						if rowIdentifier is not in seenRowData then
							set end of seenRowData to rowIdentifier

							set allElem to UI elements of (item 1 of UI element of aRow)
							set allDescriptions to description of UI elements of (item 1 of UI element of aRow)
							set joinedDescription to my joinStringList(allDescriptions)

							if joinedDescription contains filterString then
								set _num to _num + 1
								set _msgToLog to (_num as string) & ". " & pName
								my writeToRoster(_msgToLog, filteredRoster)
								set end of allCollectedMatches to pName
								set newMatchesFound to true
								my logMessage("Found match: " & pName & " (" & joinedDescription & ")", logFile)
							end if
						end if
					on error errMsg
						-- Log error but continue processing other rows
						my logMessage("Error processing filtered row " & i & ": " & errMsg, logFile)
					end try
				end repeat
			end tell
		on error errMsg
			my logMessage("Error processing participants for filtered search: " & errMsg, logFile)
			-- Continue to next iteration
		end try

			-- Track consecutive empty iterations for more robust termination
			if newMatchesFound then
				set consecutiveEmptyIterations to 0
				my logMessage("Found new filtered matches in iteration " & iteration & " (total matches: " & _num & ")", logFile)
			else
				set consecutiveEmptyIterations to consecutiveEmptyIterations + 1
				my logMessage("No new filtered matches in iteration " & iteration & " (consecutive empty: " & consecutiveEmptyIterations & ")", logFile)
			end if

			-- Only exit after multiple consecutive empty iterations
			if consecutiveEmptyIterations >= maxConsecutiveEmpty then
				my logMessage("Reached " & maxConsecutiveEmpty & " consecutive empty iterations for filter '" & filterString & "' after " & iteration & " total iterations", logFile)
				exit repeat
			end if

			-- Scroll down to see more participants - send PAGE DOWN to the participants window with error handling
			try
				-- Verify window is accessible before scrolling
				set currentParticipantWindow to my safeWindowOperation("scroll_filtered_" & iteration, currentParticipantWindow)
				tell currentParticipantWindow
					key code 121 -- PAGE DOWN key
				end tell
				delay 0.5 -- Allow UI to update
			on error errMsg
				my logMessage("Error scrolling in filtered search at iteration " & iteration & ": " & errMsg, logFile)
				-- Try to refresh window reference and scroll again
				try
					set currentParticipantWindow to my getValidParticipantsWindow()
					tell currentParticipantWindow
						key code 121 -- PAGE DOWN key
					end tell
					delay 0.5
					my logMessage("Successfully recovered scrolling in filtered search at iteration " & iteration, logFile)
				on error errMsg2
					my logMessage("Failed to recover scrolling in filtered search: " & errMsg2, logFile)
					exit repeat -- Exit if we can't scroll
				end try
			end try

		end repeat

		if iteration >= maxIterations then
			my logMessage("Warning: Reached maximum iterations (" & maxIterations & ") while gathering filtered participants", logFile)
		end if
	end tell

	if _num > 1 then
		set plural to "s"
	else
		set plural to ""
	end if
	set _summary to "=== " & filterString & " " & (_num as string) & " participant" & plural & Â
		" " & (my formatDateTime(current date)) & " ==="
	my writeToRoster(_summary, filteredRoster)

	my logMessage("Collected " & _num & " participants matching filter '" & filterString & "' using scrolling method", logFile)
end generateFilteredRoster

on howManyWaiting(waitingRoomText)
	-- Take a string like "Waiting Room (3)" and return the number in the parentheses
	set {tid, AppleScript's text item delimiters} to {AppleScript's text item delimiters, "("}
	set thePart to text item 2 of waitingRoomText
	set AppleScript's text item delimiters to ")"
	set theValue to text item 1 of thePart
	set AppleScript's text item delimiters to tid -- restore original text item delimiters
	return theValue as integer
end howManyWaiting

on clickSubElement(target, searchString)
	-- Search for a button by description that is a
	-- sub element of the target. This works for windows, or
	-- other UI elements (outlines, scroll areas, etc.)
	tell application "System Events" to tell process appName
		set elems to every UI element of target
		repeat with e in elems
			if description of e is searchString as text then
				click e
				exit repeat
			end if
		end repeat
	end tell
end clickSubElement

on letPeopleIn()
	tell application "System Events" to tell process appName
		set currentParticipantWindow to my getValidParticipantsWindow()

		-- Use error handling to access participant data robustly
		try
			tell outline 1 of scroll area 1 of currentParticipantWindow
				-- Fetch all the rows in the Participants list.
				set participantRows to every row
				-- Check to see if Waiting Room exists.
				set firstRowName to (get value of static text of UI element of row 1) as string
				if firstRowName does not start with "Waiting Room " then
					return -- Nothing to do here
				end if
				set allParticipantNames to get value of static text of UI element of rows
				set _waitingNumber to my howManyWaiting(firstRowName)
				if _waitingNumber > 1 then
					-- We will find and click the "Admit All" button.
					my clickSubElement(item 1 of UI element of row 1, "Admit All")
				else
					-- We will click the Admit button on row 2 (the participant)
					my clickSubElement(item 1 of UI element of row 2, "Admit")
				end if
				delay 1
				-- Now, we log all the people we admitted.
				-- First, gather the list of people.
				set myList to {}
				repeat with _name in allParticipantNames
					set _name to _name as text
					if _name starts with "Joined " then
						exit repeat
					else
						if not (_name starts with "Waiting Room ") then
							set myList to myList & {_name}
							my logMessage("Waiting Room: Admitted " & _name, logFile)
						end if
					end if
				end repeat
				my trackListBatched(myList, "/waiting_list")
			end tell
		on error errMsg
			my logMessage("Error in letPeopleIn function: " & errMsg, logFile)
			-- Try to get a fresh window reference and retry
			try
				set currentParticipantWindow to my getValidParticipantsWindow()
				my logMessage("Successfully refreshed window reference in letPeopleIn", logFile)
			on error errMsg2
				my logMessage("Failed to refresh window reference in letPeopleIn: " & errMsg2, logFile)
			end try
		end try
	end tell
end letPeopleIn

on createBreakoutRooms(breakoutFilename)
	if breakoutFilename starts with "/" then
		set borFilePath to breakoutFilename
	else
		set borFilePath to topLevelDirectory & breakoutFilename
	end if
	tell application "System Events"
		if (not (exists file borFilePath)) then
			error ("Missing breakout file: " & borFilePath) number -1
		end if
		set _size to size of (info for POSIX file borFilePath)
		if _size is 0 then
			error ("Empty breakout file: " & borFilePath) number -2
		end if
	end tell

	set bFile to POSIX file (borFilePath)
	set _file to open for access file bFile
	set fileContents to read _file
	close access _file

	set rooms to my filterFileContents(paragraphs of fileContents)

	set roomCount to (count rooms)
	if roomCount is 0 then
		return "No rooms are defined in the file " & borFilePath & " - exiting."
	end if

	set bor_clicked to my clickStatusMenu("Breakout")
	if not bor_clicked then
		return "Breakout room functionality not available. Make sure breakout rooms are enabled and you are a host or co-host."
	end if
	set _borWin to my findSubWindow(appName, "Breakout")
	if name of _borWin contains "In Progress" then
		return "Breakout rooms already started. Please close them first."
	else
		tell application "System Events" to tell process appName
			click _borWin
			if exists text field 1 of _borWin then
				click text field 1 of _borWin
				delay 0.5
				keystroke "	" & roomCount
				delay 0.5
				my clickSubElement(_borWin, "Assign manually")
				my clickSubElement(_borWin, "Create")
			else
				my clickSubElement(_borWin, "Recreate")
				delay 0.5
				set _menuWinName to "Menu window"
				if exists window _menuWinName then
					key code 125
					key code 125
					keystroke " "
				end if
				keystroke "\t" & roomCount
				delay 0.5
				set w to window "All existing rooms will be replaced."
				my clickSubElement(w, "Assign manually")
				my clickSubElement(w, "Recreate")
			end if
		end tell
	end if

	-- Now, with the right number of rooms, we can rename them all.
	-- We can use the _borWin window handle we already have.
	tell application "System Events" to tell process appName to tell _borWin
		tell table 1 of scroll area 1 of group 1
			set _rows to rows
			set i to 0
			repeat with _r in _rows
				set i to i + 1
				click UI element 2 of UI element 1 of _r
				delay 0.2
				keystroke item i of rooms
				delay 0.2
				keystroke "\r"
				delay 0.2
			end repeat
		end tell
	end tell
end createBreakoutRooms

on getBreakoutRooms(breakoutFilename)
	if breakoutFilename starts with "/" then
		set borFilePath to breakoutFilename
	else
		set borFilePath to topLevelDirectory & breakoutFilename
	end if

	tell application "System Events"
		if (exists file borFilePath) then
			error ("Will not overwrite file: " & borFilePath) number -3
		end if
	end tell

	set bFile to POSIX file (borFilePath)
	set _file to open for access file bFile with write permission

	set bor_clicked to my clickStatusMenu("Breakout")
	if not bor_clicked then
		return "Breakout room functionality not available. Make sure breakout rooms are enabled and you are a host or co-host."
	end if
	set _borWin to my findSubWindow(appName, "Breakout")
	set _title to (name of _borWin)
	set logEntry to "# === " & (my formatDateTime(current date)) & " " & _title
	my appendToFile(_file, logEntry, zoomRosterDebug)

	tell application "System Events" to tell process appName to tell _borWin
		tell table 1 of scroll area 1 of group 1
			set _rows to rows
			set rooms to {}
			repeat with _r in _rows
				set _room to description of UI element 1 of UI element 1 of _r as string
				if _room is "text"
					set _room to "#  " & name of UI element 1 of UI element 1 of _r as string
				end if
				set end of rooms to _room
			end repeat
		end tell
	end tell
	repeat with eachRoom in rooms
		my appendToFile(_file, eachRoom as text, zoomRosterDebug)
	end repeat
	close access _file
end getBreakoutRooms

on moveMouse(x, y)
	do shell script cliclick & " m:=" & x & ",=" & y
end moveMouse

on clickMouse(x, y)
	do shell script cliclick & " c:=" & x & ",=" & y
end clickMouse

on useParticipantMenu(cmd, oldName, newName, verbose)
	set _canRenameOthers to false
	set _renamingMe to false
	tell application "System Events" to tell process appName
		set currentParticipantWindow to my getValidParticipantsWindow()
		tell outline 1 of scroll area 1 of currentParticipantWindow
			set allParticipantNames to get value of static text of UI element of rows
			set _myName to item 1 of allParticipantNames as string
			set _renamingMe to (_myName is oldName)
			set _userIsHost to (_myName contains "(Host, me)")
			set _userIsCoHost to (_myName contains "(Co-host, me)")
			set _canRenameOthers to _userIsHost or _userIsCoHost
		end tell
	end tell
	if cmd is "rename" then
		if not _renamingMe and not _canRenameOthers then
			if verbose then
				log "ERROR: You need to be Host or Co-Host to rename other participants."
				return
			end if
		end if
		if not _renamingMe and oldName ends with "(Host)" or oldName ends with "(Co-host)" then
			log "ERROR: You can not rename a Host or Co-host."
			return
		end if
	else if cmd is "co-host" then
		if not _userIsHost then
			log "ERROR: You need to be Host to grant or withdraw Co-Host to other participants."
			return
		end if
	else if cmd is "host" then
		if not _userIsHost then
			log "ERROR: You need to be Host to relinquish Host to other participants."
			return
		end if
	end if
	tell application appName to activate
	tell application "System Events" to tell process appName
		set currentParticipantWindow to my getValidParticipantsWindow()
		tell outline 1 of scroll area 1 of currentParticipantWindow
			repeat with _r in rows
				if (get value of static text of UI element of _r) as text is oldName then
					set {_x, _y} to position of UI element 1 of UI element 1 of _r
					my moveMouse(_x, _y)
					set {_x2, _y2} to position of UI element 3 of UI element 1 of _r
					set _drag to (_x2 - _x) as integer
					do shell script cliclick & " c:+" & _drag & ",+0"
					delay 0.5
					tell menu 1 of UI element 1 of _r
						if cmd is "rename" then
							click menu item "Rename"
							delay 0.5
							keystroke newName
							keystroke "\r"
							my logMessage("Renamed: " & oldName & " => " & newName, logFile)
							exit repeat
						else if cmd is "co-host" then
							if exists menu item "Make Co-host" then
								click menu item "Make Co-host"
								delay 0.5
								keystroke "\r"
								my logMessage("Made co-host: " & oldName, logFile)
							else if exists menu item "Withdraw Co-host Permission" then
								click menu item "Withdraw Co-host Permission"
								my logMessage("Revoked co-host: " & oldName, logFile)
							end if
							exit repeat
						else if cmd is "host" then
							if exists menu item "Make Host" then
								click menu item "Make Host"
								delay 0.5
								keystroke "\r"
								my logMessage("Gave host to: " & oldName, logFile)
							end if
						end if
					end tell
				end if
			end repeat
		end tell
	end tell
end useParticipantMenu

on renameParticipant(oldName, newName, verbose)
	my useParticipantMenu("rename", oldName, newName, verbose)
end renameParticipant

on coHostParticipant(participantName)
	my useParticipantMenu("co-host", participantName, "", true)
end coHostParticipant

on giveHostToParticipant(participantName)
	my useParticipantMenu("host", participantName, "", true)
end coHostParticipant


on doBreakoutRooms(borCommand, filename)
	if borCommand is "create" then
		return my createBreakoutRooms(filename)
	end if
	if borCommand is "get" then
		return my getBreakoutRooms(filename)
	end if
	log "Error: Unknown breakout subcommand: " & borCommand
	return my usageMessage("breakout")
end doBreakoutRooms

on run argv
	set argCount to (count argv)
	if (argCount > 0) then
		set arg to item 1 of argv
	else
		set arg to "roster"
	end if
	if arg is not in knownCommands then log "Error: unknown command: " & arg
	if arg is "help" or arg is not in knownCommands then
		return my usageMessage("top")
	else if arg is "reset" then
		return my resetTrackingData()
	end if

	my setUpLogFiles()
	if arg is "server" then
		if argCount is not 2 then
			return my usageMessage("server")
		end if
		set _action to (item 2 of argv)
		if _action is not in {"start", "stop"} then
			log "Error: unknown action for \"server\" command: " & _action
			return my usageMessage("server")
		end if
		if _action is "start" then return my runBackendServer()
		-- Only possible action now is "stop"
		return my killBackendServer()
	end if

	if arg is "dashboard" then
		return my openDashboard()
	end if

	my appLogMessage("START " & arg)
	try
		my checkZoomRunning()
		my logMessage("Zoom Version: " & appVersion, logFile)
		my checkZoomMeetingRunning()
		my startParticipantWindow()
		if arg is "roster" then
			my generateRoster()
		else if arg is "hands" then
			my generateFilteredRoster("Hand raised")
		else if arg is "camera_off" then
			my generateFilteredRoster("Video off")
		else if arg is "camera_on" then
			my generateFilteredRoster("Video on")
		else if arg is "phone" then
			my generateFilteredRoster("Telephone")
		else if arg is "no_audio" then
			my generateFilteredRoster("No Audio")
		else if arg is "muted" then
			my generateFilteredRoster(" muted")
		else if arg is "unmuted" then
			my generateFilteredRoster(" unmuted")
		else if arg is "admit" then
			my letPeopleIn()
		else if arg is "breakout" then
			if argCount is not 3 then
				log my usageMessage("breakout")
			else
				log my doBreakoutRooms(item 2 of argv, item 3 of argv)
			end if
		else if arg is "rename" then
			if argCount is not 3 then
				log my usageMessage("rename")
			else
				log my renameParticipant(item 2 of argv, item 3 of argv, true)
			end if
		else if arg is "co-host" then
			if argCount is not 2 then
				log my usageMessage("co-host")
			else
				log my coHostParticipant(item 2 of argv)
			end if
		else if arg is "host" then
			if argCount is not 2 then
				log my usageMessage("host")
			else
				log my giveHostToParticipant(item 2 of argv)
			end if
		end if
	on error errMsg number errNum
		set e_str to "Error: " & errMsg
		my logMessage(e_str, logFile)
		my appLogMessage("ABORT " & arg)
		error e_str number errNum
	end try
	my appLogMessage("END " & arg)
end run
